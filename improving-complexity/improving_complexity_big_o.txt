1) Big O complexity for `improving_complexity_one` is O(n^2). the `for val in combined_array` iterator will run through every value within combined_array, and insert the value into the location where it would be sorted. Worst case scenario, every value being inserted will be the last value inserted in `sorted_array`. So, for an array of `n`, the number of iterations in the `while` loop to find the correct location will be (1 + 2 + 3 + ... + n-3 + n-2 + n-1) this is a special case of the arithmetic series that is of order n^2. Because of this big-O is  O(n^2).

2) Big O complexity for merge sort is O(n*log(n)). This is because, merge sort divides the unsorted array into halves, until all the entries are of length 1 or 0. The amount of times this occurs is log(n). On each level, there will be n elements that need to be compared to one another when being inserted. because each level will need ~n comparisons, AND there are log(n) levels, big-O is O(n*log(n)).

3) Big O is the same as answer #2 because they are both merge sort. Here I did some memory optimizations so that no additional array spaces strucutures would be used. There are always n amount of array spaces across all arrays.
